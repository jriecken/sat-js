<!DOCTYPE html>

<html>
<head>
  <title>SAT.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>SAT.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Version 0.5.0 - Copyright 2012 - 2015 -  Jim Riecken <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#106;&#105;&#109;&#114;&#64;&#106;&#105;&#109;&#x72;&#x2e;&#x63;&#x61;">&#106;&#105;&#109;&#114;&#64;&#106;&#105;&#109;&#x72;&#x2e;&#x63;&#x61;</a></p>
<p>Released under the MIT License - <a href="https://github.com/jriecken/sat-js">https://github.com/jriecken/sat-js</a></p>
<p>A simple library for determining intersections of circles and
polygons using the Separating Axis Theorem.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/** @preserve SAT.js - Version 0.5.0 - Copyright 2012 - 2015 - Jim Riecken &lt;jimr@jimr.ca&gt; - released under the MIT License. https://github.com/jriecken/sat-js */</span>

<span class="hljs-comment">/*global define: false, module: false*/</span>
<span class="hljs-comment">/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, 
  eqeqeq:true, bitwise:true, strict:true, undef:true, 
  curly:true, browser:true */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Create a UMD wrapper for SAT. Works in:</p>
<ul>
<li>Plain browser via global SAT variable</li>
<li>AMD loader (like require.js)</li>
<li>Node.js</li>
</ul>
<p>The quoted properties all over the place are used so that the Closure Compiler
does not mangle the exposed API in advanced mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {*} root - The global scope
 * @param {Function} factory - Factory that creates SAT module
 */</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, factory)</span> </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define[<span class="hljs-string">'amd'</span>]) {
    define(factory);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {
    <span class="hljs-built_in">module</span>[<span class="hljs-string">'exports'</span>] = factory();
  } <span class="hljs-keyword">else</span> {
    root[<span class="hljs-string">'SAT'</span>] = factory();
  }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-pi">  "use strict"</span>;

  <span class="hljs-keyword">var</span> SAT = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="vector">Vector</h2>
<p>Represents a vector in two dimensions with <code>x</code> and <code>y</code> properties.</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Create a new Vector, optionally passing in the <code>x</code> and <code>y</code> coordinates. If
a coordinate is not specified, it will be set to <code>0</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/** 
   * @param {?number=} x The x position.
   * @param {?number=} y The y position.
   * @constructor
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vector</span><span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = x || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = y || <span class="hljs-number">0</span>;
  }
  SAT[<span class="hljs-string">'Vector'</span>] = Vector;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Alias <code>Vector</code> as <code>V</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  SAT[<span class="hljs-string">'V'</span>] = Vector;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Copy the values of another Vector into this one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'copy'</span>] = Vector.prototype.copy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = other[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = other[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Create a new vector with the same coordinates as this on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Vector} The new cloned vector
   */</span>
  Vector.prototype[<span class="hljs-string">'clone'</span>] = Vector.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector(<span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>], <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>]);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Change this vector to be perpendicular to what it was before. (Effectively
roatates it 90 degrees in a clockwise direction)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'perp'</span>] = Vector.prototype.perp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = -x;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Rotate this vector (counter-clockwise) by the specified angle (in radians).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'rotate'</span>] = Vector.prototype.rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(angle)</span> </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = x * <span class="hljs-built_in">Math</span>.cos(angle) - y * <span class="hljs-built_in">Math</span>.sin(angle);
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = x * <span class="hljs-built_in">Math</span>.sin(angle) + y * <span class="hljs-built_in">Math</span>.cos(angle);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Reverse this vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'reverse'</span>] = Vector.prototype.reverse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = -<span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = -<span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Normalize this vector.  (make it have length of <code>1</code>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'normalize'</span>] = Vector.prototype.normalize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">this</span>.len();
    <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] / d;
      <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] / d;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Add another vector to this one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'add'</span>] = Vector.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] += other[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] += other[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Subtract another vector from this one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaiing.
   */</span>
  Vector.prototype[<span class="hljs-string">'sub'</span>] = Vector.prototype.sub = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] -= other[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] -= other[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Scale this vector. An independant scaling factor can be provided
for each axis, or a single scaling factor that will scale both <code>x</code> and <code>y</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {number} x The scaling factor in the x direction.
   * @param {?number=} y The scaling factor in the y direction.  If this
   *   is not specified, the x scaling factor will be used.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'scale'</span>] = Vector.prototype.scale = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x,y)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] *= x;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] *= y || x;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; 
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Project this vector on to another vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} other The vector to project onto.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'project'</span>] = Vector.prototype.project = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">var</span> amt = <span class="hljs-keyword">this</span>.dot(other) / other.len2();
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = amt * other[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = amt * other[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Project this vector onto a vector of unit length. This is slightly more efficient
than <code>project</code> when dealing with unit vectors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} other The unit vector to project onto.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'projectN'</span>] = Vector.prototype.projectN = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">var</span> amt = <span class="hljs-keyword">this</span>.dot(other);
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] = amt * other[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] = amt * other[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Reflect this vector on an arbitrary axis.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} axis The vector representing the axis.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'reflect'</span>] = Vector.prototype.reflect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis)</span> </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">this</span>.project(axis).scale(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] -= x;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] -= y;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Reflect this vector on an arbitrary axis (represented by a unit vector). This is
slightly more efficient than <code>reflect</code> when dealing with an axis that is a unit vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} axis The unit vector representing the axis.
   * @return {Vector} This for chaining.
   */</span>
  Vector.prototype[<span class="hljs-string">'reflectN'</span>] = Vector.prototype.reflectN = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis)</span> </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>];
    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>];
    <span class="hljs-keyword">this</span>.projectN(axis).scale(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] -= x;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] -= y;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Get the dot product of this vector and another.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector}  other The vector to dot this one against.
   * @return {number} The dot product.
   */</span>
  Vector.prototype[<span class="hljs-string">'dot'</span>] = Vector.prototype.dot = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-string">'x'</span>] * other[<span class="hljs-string">'x'</span>] + <span class="hljs-keyword">this</span>[<span class="hljs-string">'y'</span>] * other[<span class="hljs-string">'y'</span>];
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Get the squared length of this vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {number} The length^2 of this vector.
   */</span>
  Vector.prototype[<span class="hljs-string">'len2'</span>] = Vector.prototype.len2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dot(<span class="hljs-keyword">this</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Get the length of this vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {number} The length of this vector.
   */</span>
  Vector.prototype[<span class="hljs-string">'len'</span>] = Vector.prototype.len = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-keyword">this</span>.len2());
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="circle">Circle</h2>
<p>Represents a circle with a position and a radius.</p>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Create a new circle, optionally passing in a position and/or radius. If no position
is given, the circle will be at <code>(0,0)</code>. If no radius is provided, the circle will
have a radius of <code>0</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector=} pos A vector representing the position of the center of the circle
   * @param {?number=} r The radius of the circle
   * @constructor
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span><span class="hljs-params">(pos, r)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'pos'</span>] = pos || <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'r'</span>] = r || <span class="hljs-number">0</span>;
  }
  SAT[<span class="hljs-string">'Circle'</span>] = Circle;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Compute the axis-aligned bounding box (AABB) of this Circle.</p>
<p>Note: Returns a <em>new</em> <code>Polygon</code> each time you call this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Polygon} The AABB
   */</span>
  Circle.prototype[<span class="hljs-string">'getAABB'</span>] = Circle.prototype.getAABB = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">this</span>[<span class="hljs-string">'r'</span>];
    <span class="hljs-keyword">var</span> corner = <span class="hljs-keyword">this</span>[<span class="hljs-string">"pos"</span>].clone().sub(<span class="hljs-keyword">new</span> Vector(r, r));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Box(corner, r*<span class="hljs-number">2</span>, r*<span class="hljs-number">2</span>).toPolygon();
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="polygon">Polygon</h2>
<p>Represents a <em>convex</em> polygon with any number of points (specified in counter-clockwise order)</p>
<p>Note: Do <em>not</em> manually change the <code>points</code>, <code>angle</code>, or <code>offset</code> properties. Use the
provided setters. Otherwise the calculated properties will not be updated correctly.</p>
<p><code>pos</code> can be changed directly.</p>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Create a new polygon, passing in a position vector, and an array of points (represented
by vectors relative to the position vector). If no position is passed in, the position
of the polygon will be <code>(0,0)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector=} pos A vector representing the origin of the polygon. (all other
   *   points are relative to this one)
   * @param {Array.&lt;Vector&gt;=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @constructor
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Polygon</span><span class="hljs-params">(pos, points)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'pos'</span>] = pos || <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'angle'</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'offset'</span>] = <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>.setPoints(points || []);
  }
  SAT[<span class="hljs-string">'Polygon'</span>] = Polygon;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Set the points of the polygon.</p>
<p>Note: The points are counter-clockwise <em>with respect to the coordinate system</em>.
If you directly draw the points on a screen that has the origin at the top-left corner
it will <em>appear</em> visually that the points are being specified clockwise. This is just
because of the inversion of the Y-axis when being displayed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Array.&lt;Vector&gt;=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype[<span class="hljs-string">'setPoints'</span>] = Polygon.prototype.setPoints = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(points)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Only re-allocate if this is a new polygon or the number of points has changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> lengthChanged = !<span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>] || <span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>].length !== points.length;
    <span class="hljs-keyword">if</span> (lengthChanged) {
      <span class="hljs-keyword">var</span> i;
      <span class="hljs-keyword">var</span> calcPoints = <span class="hljs-keyword">this</span>[<span class="hljs-string">'calcPoints'</span>] = [];
      <span class="hljs-keyword">var</span> edges = <span class="hljs-keyword">this</span>[<span class="hljs-string">'edges'</span>] = [];
      <span class="hljs-keyword">var</span> normals = <span class="hljs-keyword">this</span>[<span class="hljs-string">'normals'</span>] = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Allocate the vector arrays for the calculated properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; points.length; i++) {
        calcPoints.push(<span class="hljs-keyword">new</span> Vector());
        edges.push(<span class="hljs-keyword">new</span> Vector());
        normals.push(<span class="hljs-keyword">new</span> Vector());
      }
    }
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>] = points;
    <span class="hljs-keyword">this</span>._recalc();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Set the current rotation angle of the polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {number} angle The current rotation angle (in radians).
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype[<span class="hljs-string">'setAngle'</span>] = Polygon.prototype.setAngle = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(angle)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'angle'</span>] = angle;
    <span class="hljs-keyword">this</span>._recalc();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Set the current offset to apply to the <code>points</code> before applying the <code>angle</code> rotation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} offset The new offset vector.
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype[<span class="hljs-string">'setOffset'</span>] = Polygon.prototype.setOffset = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(offset)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'offset'</span>] = offset;
    <span class="hljs-keyword">this</span>._recalc();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Rotates this polygon counter-clockwise around the origin of <em>its local coordinate system</em> (i.e. <code>pos</code>).</p>
<p>Note: This changes the <strong>original</strong> points (so any <code>angle</code> will be applied on top of this rotation).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype[<span class="hljs-string">'rotate'</span>] = Polygon.prototype.rotate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(angle)</span> </span>{
    <span class="hljs-keyword">var</span> points = <span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>];
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      points[i].rotate(angle);
    }
    <span class="hljs-keyword">this</span>._recalc();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Translates the points of this polygon by a specified amount relative to the origin of <em>its own coordinate
system</em> (i.e. <code>pos</code>).</p>
<p>This is most useful to change the “center point” of a polygon. If you just want to move the whole polygon, change
the coordinates of <code>pos</code>.</p>
<p>Note: This changes the <strong>original</strong> points (so any <code>offset</code> will be applied on top of this translation)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {number} x The horizontal amount to translate.
   * @param {number} y The vertical amount to translate.
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype[<span class="hljs-string">'translate'</span>] = Polygon.prototype.translate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">var</span> points = <span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>];
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      points[i].x += x;
      points[i].y += y;
    }
    <span class="hljs-keyword">this</span>._recalc();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Computes the calculated collision polygon. Applies the <code>angle</code> and <code>offset</code> to the original points then recalculates the
edges and normals of the collision polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Polygon} This for chaining.
   */</span>
  Polygon.prototype._recalc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Calculated points - this is what is used for underlying collisions and takes into account
the angle/offset set on the polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> calcPoints = <span class="hljs-keyword">this</span>[<span class="hljs-string">'calcPoints'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>The edges here are the direction of the <code>n</code>th edge of the polygon, relative to
the <code>n</code>th point. If you want to draw a given edge from the edge value, you must
first translate to the position of the starting point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> edges = <span class="hljs-keyword">this</span>[<span class="hljs-string">'edges'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>The normals here are the direction of the normal for the <code>n</code>th edge of the polygon, relative
to the position of the <code>n</code>th point. If you want to draw an edge normal, you must first
translate to the position of the starting point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> normals = <span class="hljs-keyword">this</span>[<span class="hljs-string">'normals'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Copy the original points array and apply the offset/angle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> points = <span class="hljs-keyword">this</span>[<span class="hljs-string">'points'</span>];
    <span class="hljs-keyword">var</span> offset = <span class="hljs-keyword">this</span>[<span class="hljs-string">'offset'</span>];
    <span class="hljs-keyword">var</span> angle = <span class="hljs-keyword">this</span>[<span class="hljs-string">'angle'</span>];
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-keyword">var</span> calcPoint = calcPoints[i].copy(points[i]);
      calcPoint.x += offset.x;
      calcPoint.y += offset.y;
      <span class="hljs-keyword">if</span> (angle !== <span class="hljs-number">0</span>) {
        calcPoint.rotate(angle);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Calculate the edges/normals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-keyword">var</span> p1 = calcPoints[i];
      <span class="hljs-keyword">var</span> p2 = i &lt; len - <span class="hljs-number">1</span> ? calcPoints[i + <span class="hljs-number">1</span>] : calcPoints[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> e = edges[i].copy(p2).sub(p1);
      normals[i].copy(e).perp().normalize();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Compute the axis-aligned bounding box. Any current state
(translations/rotations) will be applied before constructing the AABB.</p>
<p>Note: Returns a <em>new</em> <code>Polygon</code> each time you call this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Polygon} The AABB
   */</span>
  Polygon.prototype[<span class="hljs-string">"getAABB"</span>] = Polygon.prototype.getAABB = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> points = <span class="hljs-keyword">this</span>[<span class="hljs-string">"calcPoints"</span>];
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">var</span> xMin = points[<span class="hljs-number">0</span>][<span class="hljs-string">"x"</span>];
    <span class="hljs-keyword">var</span> yMin = points[<span class="hljs-number">0</span>][<span class="hljs-string">"y"</span>];
    <span class="hljs-keyword">var</span> xMax = points[<span class="hljs-number">0</span>][<span class="hljs-string">"x"</span>];
    <span class="hljs-keyword">var</span> yMax = points[<span class="hljs-number">0</span>][<span class="hljs-string">"y"</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
      <span class="hljs-keyword">var</span> point = points[i];
      <span class="hljs-keyword">if</span> (point[<span class="hljs-string">"x"</span>] &lt; xMin) {
        xMin = point[<span class="hljs-string">"x"</span>];
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (point[<span class="hljs-string">"x"</span>] &gt; xMax) {
        xMax = point[<span class="hljs-string">"x"</span>];
      }
      <span class="hljs-keyword">if</span> (point[<span class="hljs-string">"y"</span>] &lt; yMin) {
        yMin = point[<span class="hljs-string">"y"</span>];
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (point[<span class="hljs-string">"y"</span>] &gt; yMax) {
        yMax = point[<span class="hljs-string">"y"</span>];
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Box(<span class="hljs-keyword">this</span>[<span class="hljs-string">"pos"</span>].clone().add(<span class="hljs-keyword">new</span> Vector(xMin, yMin)), xMax - xMin, yMax - yMin).toPolygon();
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h2 id="box">Box</h2>
<p>Represents an axis-aligned box, with a width and height.</p>

            </div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Create a new box, with the specified position, width, and height. If no position
is given, the position will be <code>(0,0)</code>. If no width or height are given, they will
be set to <code>0</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).
   * @param {?number=} w The width of the box.
   * @param {?number=} h The height of the box.
   * @constructor
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Box</span><span class="hljs-params">(pos, w, h)</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'pos'</span>] = pos || <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'w'</span>] = w || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'h'</span>] = h || <span class="hljs-number">0</span>;
  }
  SAT[<span class="hljs-string">'Box'</span>] = Box;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Returns a polygon whose edges are the same as this box.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Polygon} A new Polygon that represents this box.
   */</span>
  Box.prototype[<span class="hljs-string">'toPolygon'</span>] = Box.prototype.toPolygon = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> pos = <span class="hljs-keyword">this</span>[<span class="hljs-string">'pos'</span>];
    <span class="hljs-keyword">var</span> w = <span class="hljs-keyword">this</span>[<span class="hljs-string">'w'</span>];
    <span class="hljs-keyword">var</span> h = <span class="hljs-keyword">this</span>[<span class="hljs-string">'h'</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Polygon(<span class="hljs-keyword">new</span> Vector(pos[<span class="hljs-string">'x'</span>], pos[<span class="hljs-string">'y'</span>]), [
     <span class="hljs-keyword">new</span> Vector(), <span class="hljs-keyword">new</span> Vector(w, <span class="hljs-number">0</span>), 
     <span class="hljs-keyword">new</span> Vector(w,h), <span class="hljs-keyword">new</span> Vector(<span class="hljs-number">0</span>,h)
    ]);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h2 id="response">Response</h2>
<p>An object representing the result of an intersection. Contains:</p>
<ul>
<li>The two objects participating in the intersection</li>
<li>The vector representing the minimum change necessary to extract the first object
from the second one (as well as a unit vector in that direction and the magnitude
of the overlap)</li>
<li>Whether the first object is entirely inside the second, and vice versa.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @constructor
   */</span>  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Response</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'a'</span>] = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'b'</span>] = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'overlapN'</span>] = <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'overlapV'</span>] = <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-keyword">this</span>.clear();
  }
  SAT[<span class="hljs-string">'Response'</span>] = Response;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Set some values of the response back to their defaults.  Call this between tests if
you are going to reuse a single Response object for multiple intersection tests (recommented
as it will avoid allcating extra memory)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @return {Response} This for chaining
   */</span>
  Response.prototype[<span class="hljs-string">'clear'</span>] = Response.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'aInB'</span>] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'overlap'</span>] = <span class="hljs-built_in">Number</span>.MAX_VALUE;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h2 id="object-pools">Object Pools</h2>

            </div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>A pool of <code>Vector</code> objects that are used in calculations to avoid
allocating memory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @type {Array.&lt;Vector&gt;}
   */</span>
  <span class="hljs-keyword">var</span> T_VECTORS = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) { T_VECTORS.push(<span class="hljs-keyword">new</span> Vector()); }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>A pool of arrays of numbers used in calculations to avoid allocating
memory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @type {Array.&lt;Array.&lt;number&gt;&gt;}
   */</span>
  <span class="hljs-keyword">var</span> T_ARRAYS = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) { T_ARRAYS.push([]); }</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Temporary response used for polygon hit detection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @type {Response}
   */</span>
  <span class="hljs-keyword">var</span> T_RESPONSE = <span class="hljs-keyword">new</span> Response();</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Unit square polygon used for polygon hit detection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @type {Polygon}
   */</span>
  <span class="hljs-keyword">var</span> UNIT_SQUARE = <span class="hljs-keyword">new</span> Box(<span class="hljs-keyword">new</span> Vector(), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).toPolygon();</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h2 id="helper-functions">Helper Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Flattens the specified array of points onto a unit vector axis,
resulting in a one dimensional range of the minimum and
maximum value on that axis.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Array.&lt;Vector&gt;} points The points to flatten.
   * @param {Vector} normal The unit vector axis to flatten on.
   * @param {Array.&lt;number&gt;} result An array.  After calling this function,
   *   result[0] will be the minimum value,
   *   result[1] will be the maximum value.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenPointsOn</span><span class="hljs-params">(points, normal, result)</span> </span>{
    <span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Number</span>.MAX_VALUE;
    <span class="hljs-keyword">var</span> max = -<span class="hljs-built_in">Number</span>.MAX_VALUE;
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++ ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>The magnitude of the projection of the point onto the normal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> dot = points[i].dot(normal);
      <span class="hljs-keyword">if</span> (dot &lt; min) { min = dot; }
      <span class="hljs-keyword">if</span> (dot &gt; max) { max = dot; }
    }
    result[<span class="hljs-number">0</span>] = min; result[<span class="hljs-number">1</span>] = max;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Check whether two convex polygons are separated by the specified
axis (must be a unit vector).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} aPos The position of the first polygon.
   * @param {Vector} bPos The position of the second polygon.
   * @param {Array.&lt;Vector&gt;} aPoints The points in the first polygon.
   * @param {Array.&lt;Vector&gt;} bPoints The points in the second polygon.
   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
   *   will be projected onto this axis.
   * @param {Response=} response A Response object (optional) which will be populated
   *   if the axis is not a separating axis.
   * @return {boolean} true if it is a separating axis, false otherwise.  If false,
   *   and a response is passed in, information about how much overlap and
   *   the direction of the overlap will be populated.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSeparatingAxis</span><span class="hljs-params">(aPos, bPos, aPoints, bPoints, axis, response)</span> </span>{
    <span class="hljs-keyword">var</span> rangeA = T_ARRAYS.pop();
    <span class="hljs-keyword">var</span> rangeB = T_ARRAYS.pop();</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>The magnitude of the offset between the two polygons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
    <span class="hljs-keyword">var</span> projectedOffset = offsetV.dot(axis);</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Project the polygons onto the axis.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    flattenPointsOn(aPoints, axis, rangeA);
    flattenPointsOn(bPoints, axis, rangeB);</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Move B’s range to its position relative to A.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rangeB[<span class="hljs-number">0</span>] += projectedOffset;
    rangeB[<span class="hljs-number">1</span>] += projectedOffset;</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Check if there is a gap. If there is, this is a separating axis and we can stop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (rangeA[<span class="hljs-number">0</span>] &gt; rangeB[<span class="hljs-number">1</span>] || rangeB[<span class="hljs-number">0</span>] &gt; rangeA[<span class="hljs-number">1</span>]) {
      T_VECTORS.push(offsetV); 
      T_ARRAYS.push(rangeA); 
      T_ARRAYS.push(rangeB);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>This is not a separating axis. If we’re calculating a response, calculate the overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (response) {
      <span class="hljs-keyword">var</span> overlap = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>A starts further left than B</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (rangeA[<span class="hljs-number">0</span>] &lt; rangeB[<span class="hljs-number">0</span>]) {
        response[<span class="hljs-string">'aInB'</span>] = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>A ends before B does. We have to pull A out of B</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rangeA[<span class="hljs-number">1</span>] &lt; rangeB[<span class="hljs-number">1</span>]) { 
          overlap = rangeA[<span class="hljs-number">1</span>] - rangeB[<span class="hljs-number">0</span>];
          response[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>B is fully inside A.  Pick the shortest way out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> option1 = rangeA[<span class="hljs-number">1</span>] - rangeB[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> option2 = rangeB[<span class="hljs-number">1</span>] - rangeA[<span class="hljs-number">0</span>];
          overlap = option1 &lt; option2 ? option1 : -option2;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>B starts further left than A</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> {
        response[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>B ends before A ends. We have to push A out of B</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rangeA[<span class="hljs-number">1</span>] &gt; rangeB[<span class="hljs-number">1</span>]) { 
          overlap = rangeA[<span class="hljs-number">0</span>] - rangeB[<span class="hljs-number">1</span>];
          response[<span class="hljs-string">'aInB'</span>] = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>A is fully inside B.  Pick the shortest way out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> option1 = rangeA[<span class="hljs-number">1</span>] - rangeB[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> option2 = rangeB[<span class="hljs-number">1</span>] - rangeA[<span class="hljs-number">0</span>];
          overlap = option1 &lt; option2 ? option1 : -option2;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>If this is the smallest amount of overlap we’ve seen so far, set it as the minimum overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> absOverlap = <span class="hljs-built_in">Math</span>.abs(overlap);
      <span class="hljs-keyword">if</span> (absOverlap &lt; response[<span class="hljs-string">'overlap'</span>]) {
        response[<span class="hljs-string">'overlap'</span>] = absOverlap;
        response[<span class="hljs-string">'overlapN'</span>].copy(axis);
        <span class="hljs-keyword">if</span> (overlap &lt; <span class="hljs-number">0</span>) {
          response[<span class="hljs-string">'overlapN'</span>].reverse();
        }
      }      
    }
    T_VECTORS.push(offsetV); 
    T_ARRAYS.push(rangeA); 
    T_ARRAYS.push(rangeB);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Calculates which Vornoi region a point is on a line segment.
It is assumed that both the line and the point are relative to <code>(0,0)</code></p>
<pre><code>       |       (<span class="hljs-number">0</span>)      |
(-<span class="hljs-number">1</span>)  [S]--------------[E]  (<span class="hljs-number">1</span>)
       |       (<span class="hljs-number">0</span>)      |
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} line The line segment.
   * @param {Vector} point The point.
   * @return  {number} LEFT_VORNOI_REGION (-1) if it is the left region, 
   *          MIDDLE_VORNOI_REGION (0) if it is the middle region, 
   *          RIGHT_VORNOI_REGION (1) if it is the right region.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vornoiRegion</span><span class="hljs-params">(line, point)</span> </span>{
    <span class="hljs-keyword">var</span> len2 = line.len2();
    <span class="hljs-keyword">var</span> dp = point.dot(line);</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>If the point is beyond the start of the line, it is in the
left vornoi region.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (dp &lt; <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span> LEFT_VORNOI_REGION; }</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>If the point is beyond the end of the line, it is in the
right vornoi region.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp &gt; len2) { <span class="hljs-keyword">return</span> RIGHT_VORNOI_REGION; }</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Otherwise, it’s in the middle one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> MIDDLE_VORNOI_REGION; }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Constants for Vornoi regions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @const
   */</span>
  <span class="hljs-keyword">var</span> LEFT_VORNOI_REGION = -<span class="hljs-number">1</span>;
  <span class="hljs-comment">/**
   * @const
   */</span>
  <span class="hljs-keyword">var</span> MIDDLE_VORNOI_REGION = <span class="hljs-number">0</span>;
  <span class="hljs-comment">/**
   * @const
   */</span>
  <span class="hljs-keyword">var</span> RIGHT_VORNOI_REGION = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h2 id="collision-tests">Collision Tests</h2>

            </div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Check if a point is inside a circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} p The point to test.
   * @param {Circle} c The circle to test.
   * @return {boolean} true if the point is inside the circle, false if it is not.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pointInCircle</span><span class="hljs-params">(p, c)</span> </span>{
    <span class="hljs-keyword">var</span> differenceV = T_VECTORS.pop().copy(p).sub(c[<span class="hljs-string">'pos'</span>]);
    <span class="hljs-keyword">var</span> radiusSq = c[<span class="hljs-string">'r'</span>] * c[<span class="hljs-string">'r'</span>];
    <span class="hljs-keyword">var</span> distanceSq = differenceV.len2();
    T_VECTORS.push(differenceV);</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>If the distance between is smaller than the radius then the point is inside the circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> distanceSq &lt;= radiusSq;
  }
  SAT[<span class="hljs-string">'pointInCircle'</span>] = pointInCircle;</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Check if a point is inside a convex polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Vector} p The point to test.
   * @param {Polygon} poly The polygon to test.
   * @return {boolean} true if the point is inside the polygon, false if it is not.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pointInPolygon</span><span class="hljs-params">(p, poly)</span> </span>{
    UNIT_SQUARE[<span class="hljs-string">'pos'</span>].copy(p);
    T_RESPONSE.clear();
    <span class="hljs-keyword">var</span> result = testPolygonPolygon(UNIT_SQUARE, poly, T_RESPONSE);
    <span class="hljs-keyword">if</span> (result) {
      result = T_RESPONSE[<span class="hljs-string">'aInB'</span>];
    }
    <span class="hljs-keyword">return</span> result;
  }
  SAT[<span class="hljs-string">'pointInPolygon'</span>] = pointInPolygon;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Check if two circles collide.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Circle} a The first circle.
   * @param {Circle} b The second circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   the circles intersect.
   * @return {boolean} true if the circles intersect, false if they don't. 
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCircleCircle</span><span class="hljs-params">(a, b, response)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Check if the distance between the centers of the two
circles is greater than their combined radius.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> differenceV = T_VECTORS.pop().copy(b[<span class="hljs-string">'pos'</span>]).sub(a[<span class="hljs-string">'pos'</span>]);
    <span class="hljs-keyword">var</span> totalRadius = a[<span class="hljs-string">'r'</span>] + b[<span class="hljs-string">'r'</span>];
    <span class="hljs-keyword">var</span> totalRadiusSq = totalRadius * totalRadius;
    <span class="hljs-keyword">var</span> distanceSq = differenceV.len2();</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>If the distance is bigger than the combined radius, they don’t intersect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (distanceSq &gt; totalRadiusSq) {
      T_VECTORS.push(differenceV);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>They intersect.  If we’re calculating a response, calculate the overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (response) { 
      <span class="hljs-keyword">var</span> dist = <span class="hljs-built_in">Math</span>.sqrt(distanceSq);
      response[<span class="hljs-string">'a'</span>] = a;
      response[<span class="hljs-string">'b'</span>] = b;
      response[<span class="hljs-string">'overlap'</span>] = totalRadius - dist;
      response[<span class="hljs-string">'overlapN'</span>].copy(differenceV.normalize());
      response[<span class="hljs-string">'overlapV'</span>].copy(differenceV).scale(response[<span class="hljs-string">'overlap'</span>]);
      response[<span class="hljs-string">'aInB'</span>]= a[<span class="hljs-string">'r'</span>] &lt;= b[<span class="hljs-string">'r'</span>] &amp;&amp; dist &lt;= b[<span class="hljs-string">'r'</span>] - a[<span class="hljs-string">'r'</span>];
      response[<span class="hljs-string">'bInA'</span>] = b[<span class="hljs-string">'r'</span>] &lt;= a[<span class="hljs-string">'r'</span>] &amp;&amp; dist &lt;= a[<span class="hljs-string">'r'</span>] - b[<span class="hljs-string">'r'</span>];
    }
    T_VECTORS.push(differenceV);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  SAT[<span class="hljs-string">'testCircleCircle'</span>] = testCircleCircle;</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Check if a polygon and a circle collide.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Polygon} polygon The polygon.
   * @param {Circle} circle The circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testPolygonCircle</span><span class="hljs-params">(polygon, circle, response)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Get the position of the circle relative to the polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> circlePos = T_VECTORS.pop().copy(circle[<span class="hljs-string">'pos'</span>]).sub(polygon[<span class="hljs-string">'pos'</span>]);
    <span class="hljs-keyword">var</span> radius = circle[<span class="hljs-string">'r'</span>];
    <span class="hljs-keyword">var</span> radius2 = radius * radius;
    <span class="hljs-keyword">var</span> points = polygon[<span class="hljs-string">'calcPoints'</span>];
    <span class="hljs-keyword">var</span> len = points.length;
    <span class="hljs-keyword">var</span> edge = T_VECTORS.pop();
    <span class="hljs-keyword">var</span> point = T_VECTORS.pop();</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>For each edge in the polygon:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-keyword">var</span> next = i === len - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : i + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> prev = i === <span class="hljs-number">0</span> ? len - <span class="hljs-number">1</span> : i - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> overlap = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> overlapN = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Get the edge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      edge.copy(polygon[<span class="hljs-string">'edges'</span>][i]);</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Calculate the center of the circle relative to the starting point of the edge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      point.copy(circlePos).sub(points[i]);</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>If the distance between the center of the circle and the point
is bigger than the radius, the polygon is definitely not fully in
the circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (response &amp;&amp; point.len2() &gt; radius2) {
        response[<span class="hljs-string">'aInB'</span>] = <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Calculate which Vornoi region the center of the circle is in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> region = vornoiRegion(edge, point);</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>If it’s the left region:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (region === LEFT_VORNOI_REGION) {</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>We need to make sure we’re in the RIGHT_VORNOI_REGION of the previous edge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        edge.copy(polygon[<span class="hljs-string">'edges'</span>][prev]);</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Calculate the center of the circle relative the starting point of the previous edge</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
        region = vornoiRegion(edge, point2);
        <span class="hljs-keyword">if</span> (region === RIGHT_VORNOI_REGION) {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>It’s in the region we want.  Check if the circle intersects the point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> dist = point.len();
          <span class="hljs-keyword">if</span> (dist &gt; radius) {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>No intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            T_VECTORS.push(circlePos); 
            T_VECTORS.push(edge);
            T_VECTORS.push(point); 
            T_VECTORS.push(point2);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>It intersects, calculate the overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            response[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">false</span>;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }
        T_VECTORS.push(point2);</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>If it’s the right region:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (region === RIGHT_VORNOI_REGION) {</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>We need to make sure we’re in the left region on the next edge</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        edge.copy(polygon[<span class="hljs-string">'edges'</span>][next]);</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Calculate the center of the circle relative to the starting point of the next edge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        point.copy(circlePos).sub(points[next]);
        region = vornoiRegion(edge, point);
        <span class="hljs-keyword">if</span> (region === LEFT_VORNOI_REGION) {</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>It’s in the region we want.  Check if the circle intersects the point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> dist = point.len();
          <span class="hljs-keyword">if</span> (dist &gt; radius) {</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>No intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            T_VECTORS.push(circlePos); 
            T_VECTORS.push(edge); 
            T_VECTORS.push(point);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;              
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response) {</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>It intersects, calculate the overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            response[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">false</span>;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Otherwise, it’s the middle region:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Need to check if the circle is intersecting the edge,
Change the edge into its “edge normal”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> normal = edge.perp().normalize();</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Find the perpendicular distance between the center of the 
circle and the edge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> dist = point.dot(normal);
        <span class="hljs-keyword">var</span> distAbs = <span class="hljs-built_in">Math</span>.abs(dist);</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>If the circle is on the outside of the edge, there is no intersection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (dist &gt; <span class="hljs-number">0</span> &amp;&amp; distAbs &gt; radius) {</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>No intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          T_VECTORS.push(circlePos); 
          T_VECTORS.push(normal); 
          T_VECTORS.push(point);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response) {</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>It intersects, calculate the overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          overlapN = normal;
          overlap = radius - dist;</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>If the center of the circle is on the outside of the edge, or part of the
circle is on the outside, the circle is not fully inside the polygon.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dist &gt;= <span class="hljs-number">0</span> || overlap &lt; <span class="hljs-number">2</span> * radius) {
            response[<span class="hljs-string">'bInA'</span>] = <span class="hljs-literal">false</span>;
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>If this is the smallest overlap we’ve seen, keep it. 
(overlapN may be null if the circle was in the wrong Vornoi region).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (overlapN &amp;&amp; response &amp;&amp; <span class="hljs-built_in">Math</span>.abs(overlap) &lt; <span class="hljs-built_in">Math</span>.abs(response[<span class="hljs-string">'overlap'</span>])) {
        response[<span class="hljs-string">'overlap'</span>] = overlap;
        response[<span class="hljs-string">'overlapN'</span>].copy(overlapN);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Calculate the final overlap vector - based on the smallest overlap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (response) {
      response[<span class="hljs-string">'a'</span>] = polygon;
      response[<span class="hljs-string">'b'</span>] = circle;
      response[<span class="hljs-string">'overlapV'</span>].copy(response[<span class="hljs-string">'overlapN'</span>]).scale(response[<span class="hljs-string">'overlap'</span>]);
    }
    T_VECTORS.push(circlePos); 
    T_VECTORS.push(edge); 
    T_VECTORS.push(point);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  SAT[<span class="hljs-string">'testPolygonCircle'</span>] = testPolygonCircle;</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Check if a circle and a polygon collide.</p>
<p><strong>NOTE:</strong> This is slightly less efficient than polygonCircle as it just
runs polygonCircle and reverses everything at the end.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Circle} circle The circle.
   * @param {Polygon} polygon The polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCirclePolygon</span><span class="hljs-params">(circle, polygon, response)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Test the polygon against the circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> result = testPolygonCircle(polygon, circle, response);
    <span class="hljs-keyword">if</span> (result &amp;&amp; response) {</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Swap A and B in the response.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> a = response[<span class="hljs-string">'a'</span>];
      <span class="hljs-keyword">var</span> aInB = response[<span class="hljs-string">'aInB'</span>];
      response[<span class="hljs-string">'overlapN'</span>].reverse();
      response[<span class="hljs-string">'overlapV'</span>].reverse();
      response[<span class="hljs-string">'a'</span>] = response[<span class="hljs-string">'b'</span>];
      response[<span class="hljs-string">'b'</span>] = a;
      response[<span class="hljs-string">'aInB'</span>] = response[<span class="hljs-string">'bInA'</span>];
      response[<span class="hljs-string">'bInA'</span>] = aInB;
    }
    <span class="hljs-keyword">return</span> result;
  }
  SAT[<span class="hljs-string">'testCirclePolygon'</span>] = testCirclePolygon;</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Checks whether polygons collide.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-comment">/**
   * @param {Polygon} a The first polygon.
   * @param {Polygon} b The second polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testPolygonPolygon</span><span class="hljs-params">(a, b, response)</span> </span>{
    <span class="hljs-keyword">var</span> aPoints = a[<span class="hljs-string">'calcPoints'</span>];
    <span class="hljs-keyword">var</span> aLen = aPoints.length;
    <span class="hljs-keyword">var</span> bPoints = b[<span class="hljs-string">'calcPoints'</span>];
    <span class="hljs-keyword">var</span> bLen = bPoints.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>If any of the edge normals of A is a separating axis, no intersection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; aLen; i++) {
      <span class="hljs-keyword">if</span> (isSeparatingAxis(a[<span class="hljs-string">'pos'</span>], b[<span class="hljs-string">'pos'</span>], aPoints, bPoints, a[<span class="hljs-string">'normals'</span>][i], response)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>If any of the edge normals of B is a separating axis, no intersection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; bLen; i++) {
      <span class="hljs-keyword">if</span> (isSeparatingAxis(a[<span class="hljs-string">'pos'</span>], b[<span class="hljs-string">'pos'</span>], aPoints, bPoints, b[<span class="hljs-string">'normals'</span>][i], response)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Since none of the edge normals of A or B are a separating axis, there is an intersection
and we’ve already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
final overlap vector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (response) {
      response[<span class="hljs-string">'a'</span>] = a;
      response[<span class="hljs-string">'b'</span>] = b;
      response[<span class="hljs-string">'overlapV'</span>].copy(response[<span class="hljs-string">'overlapN'</span>]).scale(response[<span class="hljs-string">'overlap'</span>]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  SAT[<span class="hljs-string">'testPolygonPolygon'</span>] = testPolygonPolygon;

  <span class="hljs-keyword">return</span> SAT;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
